# 正则表达式快速入门

正则表达式：在编写处理字符串的程序或者网页时，经常会有查找符合某些复杂规则的字符串的需求。正则表达时就是描述这些规则的工具。正则表达式就是
记录文本规则的代码。 [参考地址](https://www.jb51.net/tools/zhengze.html)
一些术语：
* `通配符`
* `元字符`  `语法格式`

# 元字符
## 常用的元字符
* `.`
* `\w` 
* `\s`
* `\`

## 字符转义
`\`

## 重复
* `*` 重复0次或者更多次
* `+` 重复一次或者更多次   
* `?` 重复0次或者1次
* `{n}` 重复n次
* `{n,}` 重复n次或者多次
* `{n,m}` 重复n次到m次
  
## 字符类
* `[aeiou]`
* `[.?!]`
* `[0-9]` 和`\d`完全一直
* `[a-z0-9A-Z]` 和`\w`完全一致
  
## 分枝
* `|` :
  
## 分组
* `(\d{1,3}\.){3}\d{1,3}` ip地址的简单校验
  
## 反义  查找不属于某个能简单定义的字符类型的字符。
* `\W` 匹配任意非数字、字母、下划线、汉字的字符 
* `\S` 匹配任意非数字的字符
* `\D` 匹配任意非数字
* `\B` 匹配不是单词开头或者结尾的位置
* `[^x]` 匹配除了x以外的任意字符
* `[^aeiou】` 匹配非元音字母
* `\S+`匹配不包含空白符的字符串
* `<a[^>]+>`匹配用尖括号括起来的以a开头的字符串

## 后向引用
使用小括号的时候，可以加组名，默认从左往右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个组号为2，以此类推。
* `\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像`go go`, 或者`kitty kitty`。
* 可以自己定义组名：
    * 指定一个表达式的组名，请使用这样的语法：`(?<Word>\w+)`(或者把尖括号换成'也行：`(?'Word'\w+)`),这样就把`\w+`的组名指定为`Word`了。
    * 反向引用组名：`\k<Word>`
    * 所以上面的例子也可以用`\b(?'Word'\w+)\b\s+\k<Word>\b`

| 分类 | 代码/语法 | 说明 | 
| - | :-: | -: | 
| 捕获 | `(exp)`| 匹配exp,并捕获文本到自动命名的组里 | 
|  | `(?<name>exp)`| 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) | 
|  | `(?:exp)`| 匹配exp,不捕获匹配的文本，也不给此分组分配组号 | 
| 零宽断言 | `(?=exp)`| 匹配exp前面的位置 | 
|  | `(?<=exp)`| 匹配exp后面的位置 | 
|  | `(?!exp)`| 匹配后面跟的不是exp的位置 | 
|  | `(?<!exp)`| 匹配前面不是exp的位置 | 
| 注释 | `(?#comment)`| 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 | 

## 零宽断言

## 负向零宽断言
零宽度负预测先行断言(?!exp)
## 注释
小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。

要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：

````
      (?<=    # 断言要匹配的文本的前缀
      <(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
      )       # 前缀结束
      .*      # 匹配任意文本
      (?=     # 断言要匹配的文本的后缀
      <\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
      )       # 后缀结束
````

## 贪婪和懒惰
* 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。
    * `a.*b`,它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
* 惰性匹配：我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。
    * `a.*?b`匹配最短的，以a开始，以b结束的字符串。
* 懒惰限定符


  | 代码/语法 | 说明 |  
  | - | - |
  | `*?` | 重复任意次，但尽可能少重复 |
  | `+？` | 重复1次或者多次，但尽可能少重复 |
  | `?？` | 重复0次或者1次，但尽可能少重复 |
  | `{n,m}?` | 重复n次到m次，但尽可能少重复 |
  | `{n,}?` | 重复n次以上，但尽可能少重复 |

## 处理选项
````
IgnoreCase(忽略大小写)	匹配时不区分大小写。   
Multiline(多行模式)	更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)   
Singleline(单行模式)	更改.的含义，使它与每一个字符匹配（包括换行符\n）。  
IgnorePatternWhitespace(忽略空白)	忽略表达式中的非转义空白并启用由#标记的注释。  
ExplicitCapture(显式捕获)	仅捕获已被显式命名的组。
````
  
## 平衡组/递归匹配
emmm....
## 其他
````
\a	报警字符(打印它的效果是电脑嘀一声)  
\b	通常是单词分界位置，但如果在字符类里使用代表退格  
\t	制表符，Tab  
\r	回车
\v	竖向制表符
\f	换页符
\n	换行符
\e	Escape
\0nn	ASCII代码中八进制代码为nn的字符
\xnn	ASCII代码中十六进制代码为nn的字符
\unnnn	Unicode代码中十六进制代码为nnnn的字符
\cN	ASCII控制字符。比如\cC代表Ctrl+C
\A	字符串开头(类似^，但不受处理多行选项的影响)
\Z	字符串结尾或行尾(不受处理多行选项的影响)
\z	字符串结尾(类似$，但不受处理多行选项的影响)
\G	当前搜索的开头
\p{name}	Unicode中命名为name的字符类，例如\p{IsGreek}
(?>exp)	贪婪子表达式
(?<x>-<y>exp)	平衡组
(?im-nsx:exp)	在子表达式exp中改变处理选项
(?im-nsx)	为表达式后面的部分改变处理选项
(?(exp)yes|no)	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
(?(exp)yes)	同上，只是使用空表达式作为no
(?(name)yes|no)	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
(?(name)yes)	同上，只是使用空表达式作为no

````




