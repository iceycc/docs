## 问题总结

### 1 js数据类型核心操作和原理
* 对象数据类型
> 在js遇到对象，会 2严格按照以下步骤操作：  
> 1、浏览器为其开辟一个新的内存空间，为了方便后期可以找到这个空间。浏览器给空间分配一个16进制的地址。
> 2、按照一定顺序，分别的把对象的`键值对`存储在内存空间中
> 3、把分配的空间地址赋值给变量（或者其他的东西），以后变量就可以通过地址找到内存空间，然后进行一些操作

* const保存对象时的也是对象地址，地址是不会改变的，但是地址指向的空间内的东西可以改变

### 2 把类数组转换成数组的方法
* 

### 3 函数的操作
* 创建函数
> 1 现开辟一个新的内存空间（为其分配了一个16进制的地址）
> 2 把函数体中编写的js代码当作`字符串`存储到空间中（只创建不执行没意义）
> 3 把分配的地址赋值给声明的函数名（function fn和var fn 操作原理其实相同，都在当前作用域声明了一个名字，此处两个名字是重复的）

* 执行函数
> 目的：执行函数中的代码
> 1 函数执行的时候，浏览器会形成一个新的私有作用域（只能执行函数体中的代码执行）
> 2 执行代码之前，先把创建函数存储的那些字符串变为真正的js表达式，按照从上到下的顺序，在私有作用域下执行
> 一个函数可以被执行N次，每一次执行相互都不会相互关系（会有间接关系，闭包）
> 形成的私有作用域把函数体中的私有变量等都包裹起来了（保护起来了），在私有作用域中操作私有变量和外界没关系，外界也无法直接的操作私有变量，我们把这种函数执行形成的保护机制成为`闭包`

### 3 栈内存 和 堆内存
* 栈内存：
    * 作用域（全局/私有），
    * 为js代码提供执行等环境（执行js代码等地方）
    * 基本数据类型是直接存放在栈内存中的
* 堆内存：
    * 存储引用类型值的（相当于一个存储的仓库）
    * 对象存储等是键值对
    * 函数存储的是代码字符串

 在项目中，我们的内存越少性能越好，我们需要把一些没用的内存处理掉
 * 处理堆内存：
    *  `var o = {}`当前对象的堆内存被变量o占用着，堆内存无法被销毁
    *  `o = null` null空对象指针（不指向任何的堆内存），此时上一次的堆内存就没有被占用类了
    *  谷歌浏览器会在空闲时间把没有被占用的堆内存自动释放（销毁/回收）
    *  ie浏览器堆内存进行计数  引用数为0  彼此引用时计数会混乱
 * 处理栈内存：
    * 一般情况下函数执行形成栈内存，函数执行完，浏览器会把形成的栈内存自动释放；todo但是有时候执行完成，栈内存不会被释放
 * 全局作用域在加载页面的时候执行，在关闭时候销毁

### 4 变量提升（预解释）
* 在`当前作用域`中，js代码自上而下执行之前，浏览器会把所有 `var/function` 关键字的进行提前的`声明或者定义`
    * 声明：declare:  var num; 在当前作用域中吼一嗓子，我有num这个名了
    * 定义: defined:  num = 12; 把声明的名字赋一个值

> 带var关键字的只是提前声明一下；带function关键字的在变量提升阶段把声明和定义都完成了

````javascript
    console.log(num)
    var num = 13;
    function fn(){
        console.log(a);
        var a = 10;
        console.log(a)
    }
    fn()
    console.log(num)
````